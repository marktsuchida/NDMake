# All field values are concatenated into a single line (aside from the leading
# whitespace on the first line, only newlines are removed).
# To set a field value with multiple lines (rarely necessary), use {{"\n"}}.
#
# Or so I thought, but Python's configparser, despite being poorly documented,
# turns out to preserve newlines in multi-line values while stripping leading
# and trailing whitespace on each line. Thus, one must use backslashes for
# line continuation and {{" "}} to include a space at the beginning or end of a
# line.

# Non-template fields: given, scope, parallel, input, producer, barrier (all
# others are template-valued).
#
# (Note: worry about barrier later; we do not needed for the initial
# implementation.)

# Special var (implicit import): g (= the global:defs template).
# Add {% import '...' as g %} to beginning of all templates (except the global
# defs itself).

# Special filters: dirname(filename), basename(filename), stripext(filename),
# fileext(filename), shesc() # add to environment's filters


# The name ("data_params" here) is optional and not used but allows multiple
# global sections to appear without their defs fields clashing.
[global data_params]
defs:
    {% set iterations = [50, 50, 200, 20] %}
    {% set moving_frames = {"S1378_1": (22, 251)} %}

    {% set bounds = {"S1378_1": (807, 807 + 216, 239, 239 + 512)} %}
    {% set velocity = {"S1378_1": -1.0} %}
    {% set seconds_per_frame = {"S1378_1": 0.23985} %}
    {% set microns_per_pixel = 0.0868 %}

    {% macro px_per_frame(experiment) -%}
    {{velocity[experiment] / microns_per_pixel * seconds_per_frame[experiment]}}
    {%- endmacro %}

[dimension EXPERIMENT]
# Parsed with shlex.split.
values: S1378_1

[dimension RESOLUTION]
range: {{len(g.iterations)}}

[dimension ITERATION]
given: RESOLUTION
range: {{g.iterations[RESOLUTION]}}

[dataset input_metadata]
scope: EXPERIMENT
filename: input/symlinks/{{EXPERIMENT}}/metadata.txt

[dimension FRAME]
given: EXPERIMENT
input: input_metadata
range_command: echo 100 # XXX Temporary, of course.
# Instead of range_command, command or match + transform can be used.
# Output of range_command or command is shlex'ed.
#
# match: template expanding into regular expression, with named
# subpattern: (?P<value>...) [allow unnamed if only one group appears in re]
# transform: template converting extracted value ("value") to domain value
#
# Note that "match" pattern is processed by 1) rendering the template, 2)
# splitting at slashes, 3) interpreting each item as a regular expression.

[dataset input_tifs]
scope: FRAME
filename: input/symlinks/{{EXPERIMENT}}/img_{{"%04d"|format(FRAME)}}_Sequence_000.tif

[subdomain FRAME.moving]
range: {{g.moving_range[EXPERIMENT]}}

[compute transform_refframe]
scope: FRAME.moving
parallel: yes
input: input_tifs
command: {% set bounds = g.bounds[EXPERIMENT] -%}
 {% set rel_frame = FRAME - g.moving_range[EXPERIMENT][0] -%}
 python linear_translation.py --type=uint16 \
     --output={{glass_refframe}} \
     --v-start={{bounds[0]}} --v-stop={{bounds[1]}} \
     --h-start={{bounds[2]}} --h-stop={{bounds[3]}} \
     --v-speed={{"%e"|format(g.px_per_frame(EXPERIMENT))}} \
     --time={{"%d"|format(rel_frame)}} \
     {{input_tifs}}

[dataset glass_refframe]
scope: FRAME.moving
producer: transform_refframe
filename: compute/glass-refframe/{{EXPERIMENT}}/{{"%04d"|format(FRAME)}}.tif

[subdomain FRAME.selection]
range:
 {% set moving_range g.moving_range[EXPERIMENT] -%}
 {{moving_range[0]}} {{moving_range[1] - g.demons_interval}}

[compute perframe_deform]
scope: FRAME.selection
parallel: 4
input: glass_refframe
command: demons \
     -histogram_match \
     -displacement_field_prefix={{iter_defo_field[0]|dirname}}/ \
     -displacement_field_suffix=.mha \
     -iterations={{g.iterations.join(",")}} \
     -maximum_step_length=0.6 \
     -displacement_field_sigma=1.8 \
     -update_field_sigma=0.0 \
     {{glass_refframe}} \
     {{glass_refframe(FRAME=int(FRAME) + g.demons_interval)}}
# Each dataset name is an object with __str__() and __call__(*, **kwargs).
# This can be used in various ways (e.g. glass_refframe(FRAME=0)).
# kwargs defaults to the current iteration element, and the value of
# __call__() is a list if the element ends up being partially specified.

[dataset iter_defo_field]
scope: FRAME.selection ITERATION
producer: perframe_deform
filename: compute/iter_field/{{EXPERIMENT}}/{{"%04d"|format(FRAME)}}/field{{"%02d"|format(RESOLUTION)}}_{{"%04d"|format(ITERATION)}}.mha

[compute get_final_field]
scope: FRAME.selection
parallel: yes
input: iter_defo_field
command: cp {{iter_defo_field[-1]}} {{unmasked_field}}

[dataset unmasked_field]
scope: FRAME.selection
producer: get_final_field
filename: compute/field/{{EXPERIMENT}}/{{"%04d"|format(FRAME)}}.mha

[compute deform_moving_image]
scope: FRAME.selection
input: unmasked_field glass_refframe
parallel: yes
command: python apply_field.py \
    {{unmasked_field}} \
    {{glass_refframe(FRAME=int(FRAME) + g.demons_interval)}} \
    {{registered_image}}

[dataset registered_image]
scope: FRAME.selection
producer: deform_moving_image
filename: compute/registered/{{EXPERIMENT}}/{{"%04d"|format(FRAME)}}.mha

[compute mask_images]
scope: FRAME.moving
input: glass_refframe
command: echo mask needs update: {{glass_frame_masks}}; exit 1

[dataset glass_frame_masks]
scope: FRAME.moving
producer: mask_images
filename: manual/masks/{{EXPERIMENT}}/{{"%04d"|format(FRAME)}}.tif

[compute mask_fields]
scope: FRAME.selection
input: glass_frame_masks unmasked_field
command: cp {{unmasked_field}} {{deformation_field}}

[dataset deformation_field]
scope: FRAME.selection
producer: mask_fields
filename: compute/field_masked/{{EXPERIMENT}}/{{"%04d"|format(FRAME)}}.mha

[compute convert_registered]
scope: FRAME.selection
input: registered_image
parallel: yes
command: python meta2tif.py {{registered_image}} {{registered_tif}}

[dataset registered_tif]
scope: FRAME.selection
producer: convert_registered
filename: compute/registered/{{EXPERIMENT}}/{{"%04d"|format(FRAME)}}.tif

[compute plot_displacement]
scope: FRAME.selection
input: glass_refframe deformation_field
parallel: yes
command: python plot_field.py --image={{glass_refframe}} \
     --title='Per-frame, {{EXPERIMENT}}: {{"% 4d"|format(FRAME)}}' \
     --vectors \
     {{deformation_field}} {{displacement_plot}}

[dataset displacement_plot]
scope: FRAME.selection
producer: plot_displacement
filename: plot/field/{{EXPERIMENT}}/{{"%04d"|format(FRAME)}}.eps

[compute accumulate_disp]
scope: EXPERIMENT
input: deformation_field
command: python accumulate_field.py \
     {% for f in deformation_field %}"{{deformation_field|shesc}}"{% endfor %} \
     {{cumul_disp[0]|dirname}}

[dataset cumul_disp]
scope: FRAME.selection
producer: accumulate_disp
filename: compute/cumul_field/{{EXPERIMENT}}/{{"%04d"|format(FRAME)}}.mha

